(* ::Package:: *)

(* ::Input:: *)
(*(* Code for the proof of Proposition 4 in of the article "Translational and great Darboux cyclides" by Niels Lubbes *)*)
(*Remove["Global`*"]*)
(**)
(*(* define notation for the classes in the sets B(X), E(X) and G(X) *)*)
(*e1={0,0,1,0,0,0};*)
(*e2={0,0,0,1,0,0};*)
(*e3={0,0,0,0,1,0};*)
(*e4={0,0,0,0,0,1};*)
(*e01={1,0,-1,0,0,0};*)
(*e02={1,0,0,-1,0,0};*)
(*e03={1,0,0,0,-1,0};*)
(*e04={1,0,0,0,0,-1};*)
(*e11={0,1,-1,0,0,0};*)
(*e12={0,1,0,-1,0,0};*)
(*e13={0,1,0,0,-1,0};*)
(*e14={0,1,0,0,0,-1};*)
(*ep1={1,1,0,-1,-1,-1};*)
(*ep2={1,1,-1,0,-1,-1};*)
(*ep3={1,1,-1,-1,0,-1};*)
(*ep4={1,1,-1,-1,-1,0};*)
(*g0={1,0,0,0,0,0};*)
(*g1={0,1,0,0,0,0};*)
(*g2={2,1,-1,-1,-1,-1};*)
(*g3={1,2,-1,-1,-1,-1};*)
(*g12={1,1,-1,-1,0,0};*)
(*g34={1,1,0,0,-1,-1};*)
(*b12={1,0,-1,-1,0,0};*)
(*bp34={0,1,0,0,-1,-1};*)
(**)
(*(* matrix for quadratic form defining intersection product between classes *)*)
(*M={{0,1,0,0,0,0},{1,0,0,0,0,0},{0,0,-1,0,0,0},*)
(*{0,0,0,-1,0,0},{0,0,0,0,-1,0},{0,0,0,0,0,-1}};*)
(**)
(*(* converts class to string *)*)
(*str[q_]:=Module[{},*)
(*If[q==e1,Return["e1"]];*)
(*If[q==e2,Return["e2"]];*)
(*If[q==e3,Return["e3"]];*)
(*If[q==e4,Return["e4"]];*)
(*If[q==e01,Return["e01"]];*)
(*If[q==e02,Return["e02"]];*)
(*If[q==e03,Return["e03"]];*)
(*If[q==e04,Return["e04"]];*)
(*If[q==e11,Return["e11"]];*)
(*If[q==e12,Return["e12"]];*)
(*If[q==e13,Return["e13"]];*)
(*If[q==e14,Return["e14"]];*)
(*If[q==ep1,Return["ep1"]];*)
(*If[q==ep2,Return["ep2"]];*)
(*If[q==ep3,Return["ep3"]];*)
(*If[q==ep4,Return["ep4"]];*)
(*If[q==g0,Return["g0"]];*)
(*If[q==g1,Return["g1"]];*)
(*If[q==g12,Return["g12"]];*)
(*If[q==g34,Return["g34"]];*)
(*If[q==g2,Return["g2"]];*)
(*If[q==g3,Return["g3"]];*)
(*Return[ToString[q]];*)
(*];*)
(**)
(*(* converts list of classes to string *)*)
(*(*q2s[q_]:=Return[str/@q]; *)*)
(**)
(*(* global default real structure, overwrite before calling comp *)*)
(*inv[q_]:={q[[1]],q[[2]],q[[4]],q[[3]],q[[6]],q[[5]]};*)
(**)
(*(* perform odot multiplication between u and v wrt set BB=B(X) *)*)
(*odot[u_,v_,BB_]:=Module[{W,i},*)
(*	If[u . M . v>0 , Return[1]];*)
(*	For[i=1,i<=Length[BB];i++,*)
(*		If[u . M . BB[[i]]>0 && v . M . BB[[i]]>0 ,Return[[1]]];*)
(*	];*)
(*	W=Select[Subsets[BB,{2}],#[[1]] . M . #[[2]]>0&];*)
(*	For[i=1,i<=Length[W];i++,*)
(*		If[u . M . W[[i,1]]>0 && v . M . W[[i,2]]>0,Return[[1]]];*)
(*	];*)
(*	Return[0];*)
(*];*)
(**)
(*(* check whether four vectors q1,q2,q3,q4 form a Clifford quartet w.r.t. elements in B(X) *)*)
(*isQuartet[q1_,q2_,q3_,q4_,BB_]:=*)
(*If[inv[q1]==q2 &&inv[q3]==q4 &&*)
(*	odot[q1,q2,BB]==0 && odot[q3,q4,BB]==0 &&*)
(*	odot[q1,q3,BB]==1 && odot[q3,q2,BB]==1 &&*)
(*	odot[q2,q4,BB]==1 && odot[q4,q1,BB]==1,*)
(*Return[True],(* else *) Return[False]];*)
(**)
(*(* checks for class e and Clifford quartet A={a,b,c,d} whether e.a>0 and e.b=e.c=e.d=0 *)*)
(*isCross[e_,A_,a_,BB_]:=Module[{j},*)
(*If[MemberQ[A,e], Return[False]];*)
(*For[j=1,j<=4,j++,If[A[[j]]!=a && odot[e,A[[j]],BB]!=0, Return[False]];];*)
(*Return[True];*)
(*];*)
(**)
(*(* verifies whether the Clifford criterion holds *)*)
(*check[T_,U_]:=Module[{i},*)
(*For[i=1,i<=Length[T],i++,*)
(*	If[ !MemberQ[Map[# . M . T[[i]]&,U],0],Return[True]];*)
(*];*)
(*Return[False];*)
(*];*)
(**)
(*(* Print all possible auxiliary tuples w.r.t. the sets BB=B(X), EE=E(X), GG=G(X), and verifies for each of these auxiliary tuples whether the Clifford criterion holds *)*)
(*comp[BB_,EE_,GG_]:=Module[{Q,i,j,A,a,T,U},*)
(*Q=DeleteDuplicatesBy[Sort]@*)
(*Select[Permutations[EE,{4}],isQuartet[#[[1]],#[[2]],#[[3]],#[[4]],BB]&]; (* list of all Clifford quartets *)*)
(*If[Length[Q]==0, Print["There exist no Clifford quartets."]];*)
(*For[i=1,i<=Length[Q],i++,*)
(*	For[j=1,j<=4,j++,*)
(*		A=Q[[i]];a=Q[[i,j]];*)
(*		T=Select[GG,# . M . a>0&];*)
(*		U=Select[EE,isCross[#,A,a,BB]&];*)
(*		Print[str/@A," ",str[a]," ",str/@T," ",str/@U," ","  Clifford criterion: "<>ToString[check[T,U]]];*)
(*	];*)
(*];*)
(*];*)


(* ::Input:: *)
(*Print["--- Blum cyclide"]*)
(*inv[q_]:={q[[1]],q[[2]],q[[4]],q[[3]],q[[6]],q[[5]]};   (* real structure of type 2A1 *)*)
(*BB={};*)
(*EE={e1,e2,e3,e4,e01,e02,e03,e04,e11,e12,e13,e14,ep1,ep2,ep3,ep4};*)
(*GG={g0,g1,g12,g34,g2,g3};*)
(*comp[BB,EE,GG]*)


(* ::Input:: *)
(*Print["--- EH1 cyclide "]*)
(*inv[q_]:={q[[1]],q[[2]],q[[4]],q[[3]],q[[6]],q[[5]]};   (* real structure of type 2A1 *)*)
(*BB={b12};*)
(*EE={e1,e2,e3,e4,e03,e04,e11,e12,e13,e14,ep1,ep2};*)
(*GG={g0,g1,g34,g3};*)
(*comp[BB,EE,GG]*)


(* ::Input:: *)
(*Print["--- HP cyclide"]*)
(*inv[q_]:={q[[1]],q[[2]],q[[4]],q[[3]],q[[6]],q[[5]]};  (* real structure of type 2A1 *)*)
(*BB={b12,bp34}*)
(*EE={e1,e2,e3,e4,e03,e04,e11,e12};*)
(*GG={g0,g1};*)
(*comp[BB,EE,GG]*)


(* ::Input:: *)
(*Print["--- S1 cyclide"]*)
(*inv[q_]:={q[[2]],q[[1]],q[[4]],q[[3]],q[[6]],q[[5]]}; (* real structure of type 3A1 *)*)
(*BB={};*)
(*EE={e1,e2,e3,e4,e01,e02,e03,e04,e11,e12,e13,e14,ep1,ep2,ep3,ep4};*)
(*GG={g12,g34};*)
(*comp[BB,EE,GG]*)


(* ::Input:: *)
(*Print["--- EE/EH2 cyclide"]*)
(*inv[q_]:={q[[2]],q[[1]],q[[4]],q[[3]],q[[6]],q[[5]]};  (* real structure of type 3A1 *)*)
(*BB={b0};*)
(*EE={e1,e2,e3,e4,e01,e12,e02,e11,e03,e14,e04,e13};*)
(*GG={g12,g34};*)
(*comp[BB,EE,GG]*)


(* ::Input:: *)
(*Print["--- S2 cyclide"]*)
(*D4={{1,0,0,0,0,0},{2,1,1,1,1,1},{-1,0,-1,0,0,0},{-1,0,0,-1,0,0},{-1,0,0,0,-1,0},{-1,0,0,0,0,-1}};*)
(*inv[q_]:=D4 . q; (* real structure of type D4 *)*)
(*BB={};*)
(*EE={e1,e2,e3,e4,e01,e02,e03,e04,e11,e12,e13,e14,ep1,ep2,ep3,ep4};*)
(*GG={g1,g2};*)
(*comp[BB,EE,GG]*)
(*(* notice that complex conjugate classes in EE intersect *)*)
(*{str/@EE,str/@inv/@EE}//TableForm*)



